# -*- coding: utf-8 -*-
"""Linked List.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bCZIjLp8ystyJp_Nnm3zisAhdWYCN6kZ

linked list is a linear data structure .
Which has two important parts are  data and next pointer for referering the next node.
**Advantages**-



*   dynamic nature
*   optimal insertion and deletion

*   stacks and queue can be easily implemented
*   no mememory wastage
"""

#Node implementation of linked list
class ListNode:
  def __init__(self,k):
    self.key=k
    self.next=None

"""Head is the first node of a linked list.
All below mentioned functions are made in reference with, that code snippet of  input and output is already given.




"""

#delete first node of a linked list
def del_first(self,head):
  if head==None:
    return None
  else:
    return head.next








#del last node of linked list
def del_last(self,head):
  if head ==None:
    return None
  elif head.next==None:
    return None
  curr =head
  while curr.next.next!=None:
    curr=curr.next
  curr.next=None
  return head










#reverse a linked list
#iterative 
def reverse_list(self,head):
  prev=None
  curr=head
  while curr:
    temp=curr.next
    curr.next=prev
    prev=curr
    curr=temp
  return prev









#middle of a linked list
def middle(self,head):
  slow=head
  fats=head
  if head==None:
    return None
  while fast and fast.next:
    slow=slow.next
    fast=fast.next.next
  return slow.data

#linked list cycle detection 
def cycle_detect(self,head):
  if head==None:
    return False
  fast=head
  slow=head
  while fast.next and fast.next.next:
    fast=fast.next.next
    slow=slow.next
    if fast==slow:
      return True
  return False










  #cycle node detection in linked list
  def cycle_node(self,head):
    if head ==None:
      return head
    fast=head
    slow=head
    while fast.next and fast.next.next:
      fast=fast.next.next
      slow=slow.next
      if slow==fast:
        slow=head
        while slow!=head:
          slow=slow.next
          fast=fast.next
        return slow
    return None









#remove duplicates from sorte list

def remove_duplicate(self,head):
  curr=head
  while curr and curr.next:
    if curr.data==curr.next.data:
      curr.next=curr.next.next
    else:
      curr=curr.next
  return head







#merge two sorted linked list
def merge(self,l1,l2):
  if l1==None:
    return l2
  elif l2==None:
    return l1
  head=ListNode()
  dummy=head
  while l1 and l2:
    if l1.data<=l2.data:
      dummy.next=l1
      l1=l1.next
    else:
      dummy.next=l2
      l2=l2.next

    dummy=dummy.next
  if l1:
    dummy.next=l1
  elif l2:
    dummy.next=l2
  return head.next








  #swapping nodes in a linked list
  def swap_nodes(self,head,k):
    slow=head
    fast=head
    n1=head
    for i in range(0,k-1):
      fast=fast.next
      n1=fast
    while fast.next!=None:
      fast=fast.next
      slow=slow.next
    n1.val,slow.val=slow.val,n1.val
    return head